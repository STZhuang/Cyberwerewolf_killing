## D04 · 事件溯源与可重放规范

### 1. 目标

采用**事件溯源 (Event Sourcing)** 作为系统唯一的数据真相来源 (Single Source of Truth)。所有改变游戏状态的操作都必须被记录为一系列不可变的、有序的事件。这套机制旨在保证对局的**绝对公平性、可验证性与完全可重放性**，同时为幂等提交、断点续播和深度审计提供坚实基础。

### 2. 事件核心结构

每一条事件都是一个描述“过去发生了什么”的独立记录。

**事件 Schema (JSON)**
```json
{
  "id": "evt_uuid_...",         // 事件自身的唯一标识 (UUID)
  "game_id": "g_123",           // 所属对局的 ID
  "idx": 42,                    // 对局内的单调递增序号，从 0 开始
  "ts": 1734103700123,          // 事件发生的精确时间戳 (UTC毫秒)
  "type": "PhaseChanged",       // 事件类型 (枚举值)
  "actor": { "seat": 3 } | { "system": "GameMaster" }, // 动作发起者
  "payload": {                  // 事件的具体内容
    "from": "DayTalk",
    "to": "Vote"
  },
  "prev_hash": "sha256_hex_...", // 上一个事件的哈希值
  "hash": "sha256_hex_..."       // 当前事件的哈希值
}
```

*   **链式哈希 (Chain-Hash)**：`hash` 是对事件关键内容进行计算得出的摘要，计算公式为 `hash = SHA256(prev_hash + canonical_json(payload) + idx + ts)`。
    *   `canonical_json` 是一种确定性的 JSON 序列化方法（键排序、无多余空格）。
    *   这种设计将所有事件链接成一个**哈希链 (Blockchain)**，任何对历史事件的篡改都会导致后续所有哈希校验失败，从而保证了日志的不可篡改性。
*   **全局唯一序列**：`(game_id, idx)` 构成了事件的全局唯一逻辑主键。

### 3. 数据存储

*   **主表**：`events` 表，严格按照事件 Schema 设计。
    *   `CREATE TABLE events (id UUID PRIMARY KEY, game_id UUID, idx INT, ts BIGINT, type VARCHAR(50), actor JSONB, payload JSONB, prev_hash CHAR(64), hash CHAR(64))`
*   **索引策略**：
    *   **聚簇索引** (Clustered Index) 在 `(game_id, idx)` 上，这是最核心的查询模式，保证了按顺序读取一个对局的所有事件时有最高的物理IO效率。
    *   在 `(game_id, ts)` 上建立辅助索引，用于按时间范围查询。
    *   在 `type` 上建立局部索引，用于分析特定类型的事件。

### 4. 状态重建与回放

事件流是“写模型”，而游戏状态是“读模型”。任何时间点的游戏状态都可以通过从头播放事件流来重建。

*   **状态重建逻辑**:
    ```python
    def reconstruct_state(game_id, target_idx):
      state = GameState.initial()
      events = query_events(game_id, from_idx=0, to_idx=target_idx)
      for event in events:
        state = state.apply(event) # apply 方法根据事件类型更新状态
      return state
    ```
*   **回放 API**:
    *   `GET /games/{gameId}/events?from_idx=0&limit=500`: 用于批量拉取事件，支持分页。
    *   `GET /games/{gameId}/events/stream?from_idx=cursor`: 使用 Server-Sent Events (SSE) 或 WebSocket 进行流式推送，用于实时观战和直播回放。
*   **客户端处理**: 客户端必须维护一个 `last_seen_idx`，并严格按 `idx` 顺序应用事件。如果发现 `idx` 不连续（丢包），应主动向服务器请求重传缺失的事件块。

### 5. 幂等性与纠错

*   **幂等提交**: 客户端发起的每个动作（如投票、发言）都必须携带一个唯一的 `reqId`。服务端在 `actions` 表或一个临时的 Redis Set 中记录 `(game_id, seat, reqId)`，确保同一请求在网络重试时只被处理一次，只产生一条对应的事件。
*   **纠错事件**: 事件一旦写入，即为不可变。如果需要修正错误（例如，管理员裁定某个操作无效），不能删除或修改旧事件，而应追加一条新的**“更正事件”**。
    *   **示例**：玩家发言被审核撤回。
        1.  `idx: 50, type: "Speak", payload: { text: "违规内容" }`
        2.  `idx: 55, type: "MessageRetracted", payload: { target_idx: 50, reason: "Inappropriate content" }`
    *   UI 层在渲染时，看到 `MessageRetracted` 事件后，会将 `idx=50` 的消息替换为“该消息已被撤回”。但底层数据和审计日志依然保留了原始记录。

### 6. 验收标准

*   **确定性验证**: 给定一个固定的游戏 `seed` 和完全相同的玩家输入序列，多次执行 `reconstruct_state` 必须能还原出完全一致的游戏状态、UI 表现和最终胜负。
*   **完整性校验**: 编写一个离线脚本，定期扫描 `events` 表，校验所有对局的 `idx` 是否连续，以及 `hash` 链是否完整无误。
*   **性能基准**: 对于一个包含 10,000 个事件的长对局，从零开始完整重建状态的时间应在 100ms 以内。流式回放 API 的 p99 延迟应低于 50ms。