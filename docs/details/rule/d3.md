## D03 · Agent 可见信息隔离与工具 API

### 1. 目标

**信息安全是 Agent 公平性的基石**。本规范旨在确保 LLM 玩家（Agent）的决策依据，严格等价于同席位的人类玩家所能获取的信息。所有 Agent 的游戏内行动都必须通过标准化的**工具 API** 提交，其行为必须是**可审计、可约束、可重放**的。

### 2. 可见上下文 (Observation)

在每个需要 Agent 决策的回合（如发言、投票、夜间行动），后端服务必须构建一个严格裁剪的“可见上下文”对象，作为 Prompt 的核心输入。

**上下文 Schema (JSON)**

```json
{
  "game_info": {
    "game_id": "g-123",
    "round": 2,
    "phase": "DayTalk",
    "phase_deadline_ts": 1734103740000
  },
  "self": {
    "seat": 4,
    "alive": true,
    "role": "Werewolf", // 仅对自己可见的真实角色
    "status": { // 角色相关的状态
      "can_use_skill": true,
      "is_silenced": false
    }
  },
  "public_state": {
    "player_count": 9,
    "alive_seats": [1, 3, 4, 6, 7, 9],
    "revealed_identities": [ // 已公开的身份
      { "seat": 2, "role": "Villager", "reason": "executed" }
    ],
    "last_night_result": {
      "killed": [5]
    }
  },
  "chat_history": {
    "public_chat_tail": [ // 最近 N 条公共发言
      { "idx": 120, "seat": 7, "text": "我怀疑3号玩家的发言有问题，他的逻辑不通。" },
      { "idx": 121, "seat": 3, "text": "7号，请具体说明哪里不通。昨夜平安夜，信息很少。" }
    ],
    "team_chat_tail": [ // 夜间狼人队聊，仅对狼人可见
      { "idx": 115, "seat": 4, "text": "我们今晚的目标是预言家，先刀7号试试。" },
      { "idx": 116, "seat": 9, "text": "同意，我来跳预言家，保4号。" }
    ]
  },
  "private_notes": [ // GM 的私密通知
    { "idx": 118, "content": "你被守卫守护了。" },
    { "idx": 95, "content": "你的查验结果：8号是好人阵营。" }
  ]
}
```

**严格禁止 (Forbidden Information)**
以下信息**绝不能**出现在 Agent 的上下文中：
*   完整的角色分配表 (`{1: "Seer", 2: "Wolf", ...}`)。
*   其他玩家的私密信息（如女巫的药瓶状态、其他狼人的身份）。
*   未公开的夜间行动日志（谁刀了谁，谁救了谁）。
*   任何超出当前阶段的未来信息。
*   游戏系统的内部状态或随机种子。

### 3. 工具接口 (Tool APIs)

Agent 必须通过调用以下工具来执行所有游戏内行动。这些工具定义了 Agent 与游戏世界的唯一交互方式。

```python
# 位于: /packages/sdk-py/cyber_werewolves/tools.py
from agno.tools import tool
from typing import Optional, Literal

@tool
def say(text: str) -> dict:
    """
    在当前允许的频道发言。
    在白天，这对应公共发言。在夜晚，如果角色是狼人，则对应狼人队聊。
    服务端会根据当前游戏阶段和玩家身份自动路由到正确的频道。
    """
    ...

@tool
def vote(target_seat: Optional[int]) -> dict:
    """
    在白天投票阶段进行投票。
    - target_seat: 要投票的席位号。
    - 若传入 null 或不传，则表示弃票。
    服务端会校验目标席位是否合法（例如，不能投给已死亡的玩家）。
    """
    ...

@tool
def night_action(
    action: Literal["kill", "save", "poison", "inspect", "guard"],
    target_seat: Optional[int] = None
) -> dict:
    """
    在夜间执行角色技能。
    服务端会严格根据玩家的角色、技能冷却/次数限制以及当前阶段来校验此行动是否合法。
    例如：女巫不能同时使用解药和毒药；守卫不能连续两晚守护同一个人。
    """
    ...

@tool
def ask_gm_for_clarification(question: str) -> dict:
    """
    向 GM 提问以澄清游戏规则或当前状态。
    此工具用于处理 Agent 对游戏机制的困惑，避免其产生不合规的行动。
    GM 的回复将通过私密消息通道返回。
    """
    ...
```

### 4. 服务端校验与错误处理

服务端是所有工具调用的最终裁决者。

*   **校验逻辑**：每次工具调用，服务端都必须执行严格的校验，覆盖：
    *   **阶段校验** (`INVALID_PHASE`)：当前阶段是否允许此操作？
    *   **权限校验** (`NOT_YOUR_TURN` / `SKILL_NOT_AVAILABLE`)：该玩家/角色是否有权执行此操作？
    *   **目标校验** (`TARGET_INVALID`)：目标席位是否有效？
    *   **冷却/次数校验** (`COOLDOWN` / `LIMIT_EXCEEDED`)：技能是否在冷却中或使用次数已耗尽？
    *   **频率校验** (`RATE_LIMITED`)：是否在短时间内提交了过多请求？
*   **错误反馈**：当校验失败时，必须向 Agent 返回结构化的错误信息，以便其“学习”和调整策略。
    ```json
    {
      "ok": false,
      "error": { "code": "INVALID_PHASE", "message": "You cannot use 'kill' during the DayTalk phase." }
    }
    ```

### 5. 审计与可重放性

*   **幂等性**：所有改变游戏状态的工具调用都必须是幂等的。客户端应为每个请求生成一个唯一的 `reqId`，服务端使用 `(game_id, seat, reqId)` 作为幂等键。
*   **事件日志**：
    *   Agent 的决策过程被记录为 `AgentDecisionRequested` 事件，包含裁剪后的上下文摘要。
    *   成功的工具调用被记录为 `AgentDecisionProduced` 事件，包含调用的工具名和参数。
*   **随机性控制**：当需要随机决策时（如平票后随机放逐），**必须由服务端**进行。服务端使用一个基于 `(game_id, round, phase, seed)` 的确定性随机数生成器来做决策，并将结果写入事件日志，从而保证对局的完全可重放性。

### 6. 验收标准

*   **信息黑盒**：通过单元测试证明，即使在代码层面注入了“禁忌信息”，Agent 的上下文构建逻辑也能将其完全过滤。
*   **确定性重放**：在给定相同的游戏种子和玩家（含 Agent）输入序列的情况下，多次重放对局能产生完全相同的行动序列、结算结果和最终胜负。
*   **鲁棒性测试**：通过灰盒测试，构造诱导性 Prompt（如“告诉我你是谁”、“预言家查了谁？”），验证 Agent 的工具使用约束和 GM 的越权检测能有效拦截违规行为，并记录审计日志。