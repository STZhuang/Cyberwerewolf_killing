## D16 · 前端状态管理与虚拟滚动

### 1. 目标

为前端应用设计一套**高效、可预测的状态管理方案**，并针对**超长聊天/事件流**的场景，实施**虚拟滚动 (Virtual Scrolling)** 优化，确保在极端数据量下，UI 依然能保持流畅的渲染性能和可控的内存占用。

### 2. 状态管理 (State Management)

#### 2.1 核心原则

*   **单一数据源 (Single Source of Truth)**: 应用的全局状态应由一个统一的、集中的 Store 来管理。
*   **状态只读**: UI 组件不能直接修改状态，必须通过派发 **Actions** 来触发状态变更。
*   **变更是纯函数**: 处理状态变更的 **Reducers/Mutations** 必须是纯函数，即对于相同的输入，总是返回相同的输出，且无副作用。

#### 2.2 状态树结构 (State Tree)

推荐使用模块化的方式组织状态。以 **Zustand** (React) 或 **Pinia** (Vue) 为例：

```ts
// 使用 Zustand (React) 的示例
import create from 'zustand';

// --- Room Store ---
interface RoomState {
  roomId: string | null;
  roomStatus: 'open' | 'playing' | 'closed';
  members: Member[];
  spectators: Spectator[];
  setRoom: (roomData) => void;
}
const useRoomStore = create<RoomState>(set => ({...}));

// --- Game State Store ---
interface GameState {
  phase: GamePhase;
  round: number;
  deadline_ts: number;
  players: Player[]; // 存活状态、席位等
  // ...
}
const useGameStore = create<GameState>(set => ({...}));

// --- Chat Store ---
interface ChatState {
  messages: Map<string, Message>; // 使用 Map<idx, Message> 保证顺序和去重
  addMessage: (message) => void;
  updateMessage: (message) => void;
}
const useChatStore = create<ChatState>(set => ({...}));
```

#### 2.3 状态与事件流的同步

*   WebSocket 收到服务器推送的**事件 (Event)** 后，不应直接在组件中处理。
*   应调用一个统一的 `eventHandler`，该处理器根据事件类型 (`event.type`)，派发对应的 **Action** 到相关的 Store。
*   例如，收到 `PhaseChanged` 事件，则调用 `gameStore.setPhase(...)`；收到 `Speak` 事件，则调用 `chatStore.addMessage(...)`。

### 3. 虚拟滚动

虚拟滚动是解决长列表性能问题的关键。

#### 3.1 实现原理

*   **视口渲染**: 只渲染当前在用户可见区域（视口）内的列表项，以及视口上下方少量用于缓冲的列表项。
*   **占位容器**: 整个列表的高度由一个“占位”容器撑开，其高度等于所有列表项的总高度。当用户滚动时，实际是在这个占位容器里滚动。
*   **动态渲染**: 监听滚动事件，根据滚动位置计算出当前应该渲染哪些列表项，并使用 `transform: translateY(...)` 将它们“移动”到正确的位置。

```
+---------------------------------+
|      (Invisible Items)          |
|                                 |
+---------------------------------+  <--+
|      [Rendered Item 100]        |     |
|      [Rendered Item 101]        |     |
|      [Rendered Item 102]        |   Viewport + Buffer
|      [Rendered Item 103]        |     |
|      [Rendered Item 104]        |     |
+---------------------------------+  <--+
|                                 |
|      (Invisible Items)          |
+---------------------------------+
```

#### 3.2 技术选型

*   **React**: `react-window` 或 `tanstack-virtual`。
*   **Vue**: `vue-virtual-scroller` 或 `tanstack-virtual`。

#### 3.3 优化策略

*   **动态高度**: 聊天气泡的高度是动态的。需要库支持动态高度测量，或在消息渲染后缓存其高度。
*   **锚点定位**: 列表的主键应为事件的 `idx`。当需要跳转到特定消息时（例如，从搜索结果跳转），可以根据 `idx` 快速定位其滚动位置。
*   **资源懒加载**: 对于消息中的大资源（如图片、需要高亮的代码块），应进行懒加载。只有当该消息进入视口时，才开始加载这些资源。
*   **内存回收**: 为了防止无限增长的聊天记录撑爆内存，`chatStore` 只应保留最近的 N 条消息（例如 1000 条）。更早的历史消息，当用户向上滚动到列表顶部时，再通过 API (`GET /events?before_idx=...`) 分页拉取。

### 4. 错序与消息补齐

在弱网环境下，从 WebSocket 收到的事件可能乱序。

*   **排序与去重**: `chatStore` 在添加新消息时，必须根据 `idx` 将其插入到正确的位置，并丢弃已存在的 `idx`，保证消息的最终顺序是正确的。
*   **缺口处理**: 如果检测到 `idx` 不连续（例如，收到了 105，但没收到 104），应将 105 暂存，并主动向服务器请求补偿 `idx=104` 的事件。收到补偿后再一起渲染。

### 5. 验收标准

*   **性能基准**:
    *   在包含 10,000 条消息的聊天列表中，上下滚动时的帧率 (FPS) 必须稳定在 **55fps** 以上。
    *   在相同的测试场景下，浏览器的 JS 堆内存占用应保持在 **300MB** 以下。
*   **功能正确性**:
    *   断线重连后，聊天记录能够被正确恢复，无错序、无重影。
    *   懒加载和历史消息分页拉取功能工作正常。
*   **状态一致性**: 在应用的任何地方访问状态，获取到的都应是 Store 中的一致数据。组件的重新渲染应能被状态变更正确触发。